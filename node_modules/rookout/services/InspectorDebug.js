"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InspectorDebug = void 0;

var _logger = require("../logger");

var _exceptions = require("../exceptions");

var _IgnoredNodeModules = require("./IgnoredNodeModules");

var _InspectorFrameNamespace = _interopRequireDefault(require("../processor/namespaces/InspectorFrameNamespace"));

var _InspectorStackNamespace = _interopRequireDefault(require("../processor/namespaces/InspectorStackNamespace"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inspector = require('inspector');

const url = require('url');

const rook = require("../index");

const config = require("../config");

class InspectorDebug {
  constructor(userLine, scriptLoaded, getScript, dbgService) {
    if (InspectorDebug.isElectron()) {
      InspectorDebug.verifyInspectFlagEnabledUnderElectron();
    } else {
      // Setting the --inspect CLI flag means the inspector will be active, so we can't
      // run this verification in that case.
      InspectorDebug.verifyNoDebuggerConnected();
    }

    const self = this;
    this.getScriptCallback = getScript;
    this.userLine = userLine;
    this.scriptLoaded = scriptLoaded;
    this.dbgService = dbgService;
    this.positionsToBreakpoints = {};
    this.breakpointsToPositions = {};
    this.loadedScriptsCount = 0;
    this.maxLoadedScripts = parseInt(process.env.ROOKOUT_MAX_SCRIPTS) || 20000;
    this.initialSessionStartTime = new Date();
    this.startSession();
  }

  async startSession() {
    this.session = new inspector.Session();

    try {
      this.session.connect();
    } catch (e) {
      throw new _exceptions.RookInspectorConnectFailed(e);
    }

    const self = this; // Scripts may not be released just by restarting a session, so collect garbage
    // immediately after starting a session

    this.session.post('HeapProfiler.collectGarbage');
    this.session.on('Debugger.scriptParsed', script => {
      if (self.session === null) {
        return;
      }

      try {
        if (new Date() - this.initialSessionStartTime < config.MAX_SCRIPT_COUNT_INIT_TIME) {
          self.maxLoadedScripts++;
        }

        self.loadedScriptsCount++;

        if (self.loadedScriptsCount > self.maxLoadedScripts && rook.savedOptions !== null) {
          this.dbgService.restart().catch(() => _logger.logger.exception("Failed to restart"));
          return;
        }

        let scriptURL = script.params.url;

        if (scriptURL === "") {
          return;
        } // URLs instead of paths started in 10.12 which also introduced this
        // url.fileURLToPath. We assume we will not receive URLs before 10.12


        if (scriptURL.startsWith("file:") && url.fileURLToPath !== undefined) {
          scriptURL = url.fileURLToPath(scriptURL);
        }

        if ((0, _IgnoredNodeModules.isBlackListedModule)(scriptURL)) {
          return;
        }

        self.post('Debugger.getScriptSource', {
          scriptId: script.params.scriptId
        }, (err, scriptSource) => {
          if (err) {
            _logger.logger.exception("Failed to get script source", err);

            return;
          }

          try {
            self.scriptLoaded(script.params.scriptId, scriptURL, scriptSource.scriptSource);
          } catch (error) {
            _logger.logger.exception("Exception when processing script source callback", error);
          }
        });
      } catch (error) {
        _logger.logger.exception("Exception when processing script parse callback", error);
      }
    });
    this.session.on('Debugger.paused', message => {
      if (self.session === null) {
        return;
      }

      try {
        const pos = self.breakpointsToPositions[message.params.hitBreakpoints[0]];

        if (!pos) {
          _logger.logger.error("Aug not found! %s", message.params.hitBreakpoints[0]);
        } else {
          self.userLine(pos, new _InspectorFrameNamespace.default(self, message.params.callFrames[0]), new _InspectorStackNamespace.default(self, message.params.callFrames));
        }
      } catch (error) {
        _logger.logger.exception(error);
      } finally {
        this.post("Debugger.resume");
      }
    });
    this.session.on('error', error => {
      try {
        _logger.logger.exception('InspectorDebugger error', error);
      } catch (e) {}
    });
    await this.post('Debugger.enable');
    await this.post('Debugger.setBreakpointsActive', {
      active: true
    });
  }

  static verifyNoDebuggerConnected() {
    // inspector.url doesn't exist in node.js v8.0.0 - it was added in v8.1.0
    // (although the docs would have you believe it's support in v8.x)
    if (inspector.url !== undefined && inspector.url() !== undefined) {
      throw new _exceptions.RookOtherDebuggerConnected();
    }
  } //NOTE:: if inspect is not specified under electron, inspector api will fail to load
  //NOTE:: its important that this function will happen here and not in the InspectorDebug
  //          since we actually want to fail if inspect is not specified


  static verifyInspectFlagEnabledUnderElectron() {
    let processArguments = process.argv.toString();

    if (!processArguments.includes('--inspect')) {
      throw new _exceptions.RookElectronInspectFlagNotSet();
    }
  }

  static isElectron() {
    return process.argv.toString().includes('electron');
  }

  async restart() {
    await this.close();
    this.loadedScriptsCount = 0;
    this.startSession();
  }

  setBreak(pos, aug) {
    let result = {};
    let scriptURL = pos.filename;

    if (url.pathToFileURL !== undefined) {
      scriptURL = url.pathToFileURL(scriptURL);
    }

    let key = 'aug-' + aug.augId;

    let info = process.__rookout_backchannel.create(key);

    info.aug = aug;
    this.post('Debugger.setBreakpointByUrl', {
      url: scriptURL,
      lineNumber: pos.lineno - 1,
      columnNumber: pos.column + 1
    }, (error, response) => {
      result.error = error;
      result.response = response;
    });

    if (null != result.error) {
      throw new _exceptions.RookInspectorSetBreakpointFailed(result.error);
    }

    this.positionsToBreakpoints[pos.toKey()] = result.response.breakpointId;
    this.breakpointsToPositions[result.response.breakpointId] = pos;
  }

  async clearBreak(pos) {
    // If we have an object, hash it
    if (pos.toKey) {
      pos = pos.toKey();
    }

    const breakpointId = this.positionsToBreakpoints[pos];

    if (undefined === breakpointId) {
      return;
    }

    delete this.positionsToBreakpoints[pos];
    delete this.breakpointsToPositions[breakpointId];
    let result = {};
    await this.post('Debugger.removeBreakpoint', {
      breakpointId: breakpointId
    }, error => {
      result.error = error;
    });

    if (null != result.error) {
      _logger.logger.error("Failed to remove breakpoint", result.error);
    }
  }

  async clearAllBreaks() {
    let positions = Object.keys(this.positionsToBreakpoints);
    await Promise.all(positions.map(position => this.clearBreak(position)));
    this.positionsToBreakpoints = {};
    this.breakpointsToPositions = {};
  }

  post(message_id, params, cb) {
    // Don't reject as the promise was added after-the-fact:
    // there are many places in the code that won't catch rejected promises,
    // which could crash user code.
    // If you want to reject here, you first have to find all uses of post and adapt them
    // to handle rejected promises.
    return new Promise(resolve => {
      const myCb = (...args) => {
        if (cb !== undefined) {
          cb(...args);
        }

        resolve();
      };

      if (this.session === null) {
        if (cb !== undefined) {
          cb(new Error("No debug session"), null);
        }

        return;
      }

      this.session.post(message_id, params, myCb);
    });
  }

  getProperties(object, ownProperties = true) {
    let result = {};
    this.post('Runtime.getProperties', {
      objectId: object.objectId,
      ownProperties: ownProperties
    }, (error, value) => {
      if (error) {
        result.error = error;
      } else {
        result.value = value.result;
      }
    });

    if (result.error) {
      throw new RookInspectorFailedToGetObject(object);
    }

    return result.value;
  }

  getScript(scriptId) {
    return this.getScriptCallback(scriptId);
  }

  async close() {
    if (this.session) {
      await this.clearAllBreaks();
      await this.post('Debugger.setBreakpointsActive', {
        active: false
      });
      await this.post('Debugger.disable');
      await this.post('Debugger.resume'); // just in case

      this.session.disconnect();
      this.session = null;
    }
  }

  scripts() {
    return [];
  }

}

exports.InspectorDebug = InspectorDebug;
//# sourceMappingURL=InspectorDebug.js.map